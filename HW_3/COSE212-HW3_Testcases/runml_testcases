{
  UNIT => Unit;
  (NOT (ISNIL (APPEND (NIL, NIL)))) => Bool false;
  (DIV (ADD (CONST 10, CONST 8), SUB (MUL (CONST 2, CONST 4), CONST 2))) => Int 3
  (LET ("empty", PROC ("l", ISNIL (VAR "l")), CALL (VAR "empty", CONS (CONST 3, NIL)))) => Bool false;
  (LET ("add2", PROC ("n", PROC ("x", ADD (VAR "n", VAR "x"))), CALL (CALL (VAR "add2", CONST 1), CONST 3))) => Int 4;
  (LETREC ("ffact", "x", IF (LESS (VAR "x", CONST 2), CONST 1, MUL(VAR "x", CALL (VAR "ffact", SUB (VAR "x", CONST 2)))), CALL (VAR "ffact", CONST 13))) => Int 135135;
  (LETREC ("min", "l", IF (ISNIL (TAIL (VAR "l")), HEAD (VAR "l"), LET ("tl_min", CALL (VAR "min", TAIL (VAR "l")), IF (LESS (VAR "tl_min", HEAD (VAR "l")), VAR "tl_min", HEAD (VAR "l")))), CALL (VAR "min", CONS (CONST 5, CONS (CONST 8, CONS (CONST 4, CONS (CONST 7, CONS (CONST 2, CONS (CONST 6, NIL))))))))) => Int 2;
  (LETREC ("sum", "l", IF (ISNIL (VAR "l"), CONST 0, ADD (HEAD (VAR "l"), CALL (VAR "sum", TAIL (VAR "l")))), CALL (VAR "sum", CONS (CONST 5, CONS (CONST 4, CONS (CONST 7, CONS (CONST 11, NIL))))))) => Int 27;
  (LET ("fact2", PROC ("n", LETMREC(("factodd", "x", IF (EQUAL (VAR "x", CONST 1), CONST 1, MUL (VAR "x", CALL (VAR "facteven", SUB (VAR "x", CONST 1))))), ("facteven", "x", IF (EQUAL (VAR "x", CONST 0), CONST 1, MUL (VAR "x", CALL (VAR "factodd", SUB (VAR "x", CONST 1))))), IF (EQUAL (VAR "n", MUL (CONST 2, DIV (VAR "n", CONST 2))), CALL (VAR "facteven", VAR "n"), CALL (VAR "factodd", VAR "n")))), CALL(VAR "fact2", CONST 8))) => Int 40320;
  (LETMREC (("f", "x", IF (LESS (CONST 1, VAR "x"), CALL (VAR "g", SUB (VAR "x", CONST 1)), CONST 0)), ("g", "x", ADD (CONST 1, CALL (VAR "f", VAR "x"))), CALL (VAR "f", CONST 5))) => Int 4;
  (IF (CONST 0, TRUE, FALSE)) => raise UndefinedSemantics;
  (LESS (MUL (CONST 3, CONST 2), CONST 5)) => Bool false;
  (EQUAL (TRUE, CONST 0)) => raise UndefinedSemantics;
  (TAIL (APPEND (CONS (CONST 1, NIL), CONS (CONST 2, CONS (CONST 3, NIL))))) => List [Int 2; Int 3];
  (LET ("x", CONST 10, IF (LESS (VAR "x", TRUE), CONST 1, CONST 2))) => raise UndefinedSemantics;
  (SEQ (CONST 1, IF (LESS (CONST 5, CONST 6), DIV (CONST 4, CONST 2), CONST 3))) => Int 2;
  (CALL (PROC ("x", CONS (VAR "x", NIL)), CONST 1)) => List [Int 1];
  (LET ("f", PROC ("x", ADD (VAR "x", VAR "x")), CALL (VAR "f", CONST 5))) => Int 10;
  (LET ("x", CONST 5, LET("x" ,ADD (VAR "x", VAR "x"), VAR "x"))) => Int 10;
  (LETREC ("factorial", "x", IF(LESS (VAR "x", CONST 1), CONST 1, MUL (VAR "x", CALL (VAR "factorial", SUB (VAR "x", CONST 1)))), CALL (VAR "factorial", CONST 5))) => Int 120;
  (LET ("f", PROC ("x", PROC ("y", PROC ("z", ADD (VAR "x", ADD (VAR "y", VAR "z"))))), CALL (CALL (CALL (VAR "f", CONST 1),CONST 2),CONST 3))) => Int 6;
  (LETREC ("drop", "f", PROC ("lst", IF (ISNIL (VAR "lst"), NIL, IF (CALL (VAR "f", HEAD (VAR "lst")), CALL (CALL (VAR "drop", VAR "f"), TAIL(VAR "lst")), VAR "lst"))), CALL (CALL (VAR "drop", PROC ("x", LESS (CONST 5, VAR "x"))), CONS (CONST 1, CONS (CONST 3, CONS (CONST 7, NIL)))))) => List [Int 1;Int 3;Int 7];
  (LETREC ("concat", "lst", IF (ISNIL (VAR "lst"), NIL, APPEND (HEAD (VAR "lst"), CALL (VAR "concat", TAIL (VAR "lst")))), CALL (VAR "concat", CONS (CONS (CONST 1, CONS (CONST 2, NIL)), CONS (CONS (CONST 3, CONS (CONST 4, CONS (CONST 5, NIL))), NIL))))) => List [Int 1;Int 2;Int 3;Int 4;Int 5];
  (LET ("x", CONST 2, LETMREC (("f", "x", CALL (VAR "g", VAR "x")), ("g", "y", ADD (VAR "x", CONST 2)), CALL (VAR "f", CONST 5)))) => Int 4;
  (LETMREC (("f", "lst", IF (ISNIL (VAR "lst"), NIL, APPEND (CALL (VAR "f", TAIL (VAR "lst")), CALL (VAR "g", VAR "lst")))), ("g", "lst", IF (ISNIL (VAR "lst"), NIL, CONS (HEAD (VAR "lst"), CALL (VAR "f", TAIL (VAR "lst"))))), CALL (VAR "f", CONS (CONST 1, CONS (CONST 3, CONS (CONST 5, NIL)))))) => List [Int 5;Int 3;Int 5;Int 1;Int 5;Int 3;Int 5];
  (LET("x", CONST 2, LETREC("f", "y", IF (EQUAL (VAR "y", CONST 0), CONST 0, ADD (VAR "x", CALL (VAR "f", SUB(VAR "y", CONST 1)))), LET ("x", CONST 5, CALL (VAR "f", VAR "x"))))) => Int 10;
  (LETREC ("iter", "n", PROC ("f", IF (EQUAL (VAR "n", CONST 0), PROC("x", VAR "x"), PROC ("x", CALL (CALL (CALL (VAR "iter", SUB (VAR "n", CONST 1)), VAR "f"), CALL (VAR "f", VAR "x"))))), CALL (CALL (CALL (VAR "iter", CONST 3), PROC ("x", ADD (VAR "x", CONST 2))), CONST 3))) => Int 9;
  (LETMREC (("f", "n", IF (LESS (CONST 0, VAR "n"), ADD (CALL (VAR "f", SUB (VAR "n", CONST 1)), MUL (VAR "n", CALL (VAR "g", VAR "n"))), CONST 0)), ("g", "n", IF (LESS (CONST 0, VAR "n"), ADD (CONST 1, CALL (VAR "f", SUB (VAR "n", CONST 1))), CONST 1)), CALL (VAR "f", CONST 5))) =>  Int 719;
  (LETMREC (("g", "x", CALL (VAR "f", CONST 1)), ("f", "y", ADD (VAR "x", CONST 2)), CALL (VAR "g", CONST 2))) => raise Failure ("variable x is not bound in env");
  (LETMREC (("sub", "x", IF (EQUAL (VAR "x", CONST 0), CONST 0, ADD (VAR "x", CALL (VAR "sub", SUB (VAR "x", CONST 1))))), ("f", "x", LET ("x", DIV (VAR "x", CONST 2), CALL (VAR "sub", VAR "x"))), CALL (VAR "f", CONST 10))) => Int 15;
  (LETMREC (("male", "x", IF (EQUAL (VAR ("x"), CONST 0), CONST 0, SUB (VAR ("x"), CALL (VAR ("female"), CALL (VAR ("male"), SUB (VAR ("x"), CONST 1)))))), ("female", "x", IF (EQUAL (VAR ("x"), CONST 0), CONST 1, SUB (VAR ("x"), CALL (VAR ("male"), CALL (VAR ("female"), SUB (VAR ("x"), CONST 1)))))), SUB (CALL (VAR ("male"), CONST 20), CALL (VAR ("female"), CONST 10)))) => Int 6;
  (LETMREC (("male", "x", IF (EQUAL (VAR ("x"), CONST 0), CONST 0, SUB (VAR ("x"), CALL (VAR ("female"), CALL (VAR ("male"), SUB (VAR ("x"), CONST 1)))))), ("female", "x", IF (EQUAL (VAR ("x"), CONST 0), CONST 1, SUB (VAR ("x"), CALL (VAR ("male"), CALL (VAR ("female"), SUB (VAR ("x"), CONST 1)))))), LETREC ("range"    , "n", IF (EQUAL (VAR ("n"), CONST 0), CONS (CONST 0, NIL), CONS (VAR ("n"), CALL (VAR ("range"), SUB (VAR ("n"), CONST 1)))), LETREC ("male_sequence", "l", IF (ISNIL (VAR ("l")), NIL, CONS (CALL (VAR ("male"), HEAD (VAR ("l"))), CALL (VAR ("male_sequence"), TAIL (VAR ("l"))))), CALL (VAR ("male_sequence"), CALL (VAR ("range"), CONST 5)))))) => List [Int 3; Int 2; Int 2; Int 1; Int 0; Int 0];
  (LET ("moda", PROC ("x", PROC ("y", SUB (VAR ("x"), MUL (VAR ("y"), DIV (VAR ("x"), VAR ("y")))))), LET ("step", PROC ("x", IF (EQUAL (CALL (CALL (VAR ("moda"), VAR ("x")), CONST 2), CONST 0), DIV (VAR ("x"), CONST 2), ADD (MUL (CONST 3, VAR ("x")), CONST 1))), LETREC ("collatzcount", "num", IF (EQUAL (VAR ("num")    , CONST 1), CONST 0, LET ("new_num", CALL (VAR ("step"), VAR ("num")), ADD (CONST 1, CALL (VAR ("collatzcount"), VAR ("new_num"))))), CALL (VAR ("collatzcount"), CONST 871))))) => Int 178;
  (LET ("lst", CONS (CONST 1, CONS (CONST 2, CONS (CONST 1, CONS (CONST 2, CONS (CONST 1, CONS (CONST 2, NIL)))))), LETMREC (("s_need_one", "xs", IF (ISNIL (VAR ("xs")), TRUE, IF (EQUAL (HEAD (VAR ("xs")), CONST 1), CALL (VAR ("s_need_two"), TAIL (VAR ("xs"))), FALSE))), ("s_need_two", "xs", IF (ISNIL (VAR ("xs")),     FALSE, IF (EQUAL (HEAD (VAR ("xs")), CONST 2), CALL (VAR ("s_need_one"), TAIL (VAR ("xs"))), FALSE))), LET ("matches", PROC ("x", CALL (VAR ("s_need_one"), VAR ("x"))), CALL (VAR ("matches"), VAR ("lst")))))) => Bool true;
  (LET ("matches", PROC ("x", LETMREC (("s_need_one", "xs", IF (ISNIL (VAR ("xs")), TRUE, IF (EQUAL (HEAD (VAR ("xs")), CONST 1), CALL (VAR ("s_need_two"), TAIL (VAR ("xs"))), FALSE))), ("s_need_two", "xs", IF (ISNIL (VAR ("xs")), FALSE, IF (EQUAL (HEAD (VAR ("xs")), CONST 2), CALL (VAR ("s_need_one"), TAIL (VAR ("xs"))), FALSE))), CALL (VAR ("s_need_one"), VAR ("x")))), CALL (VAR ("matches"), CONS (CONST 1, CONS (CONST 2, CONS (CONST 1, CONS (CONST 1, CONS (CONST 1, CONS (CONST 1, NIL))))))))) => Bool false;
  (CALL (CALL (PROC ("x", PROC ("y", EQUAL (VAR "x", VAR "y"))), NIL), NIL)) => raise UndefinedSemantics;
  (CALL (CALL (PROC ("x", PROC ("y", LESS (VAR "x", VAR "y"))), CONST 0), CONST 1)) => Bool true;
  (LET ("pythagoras", PROC ("a", PROC ("b", PROC ("c", EQUAL (ADD (MUL (VAR "a", VAR "a"), MUL (VAR "b", VAR "b")), MUL (VAR "c", VAR "c"))))), CALL (CALL (CALL (VAR "pythagoras", CONST 3), CONST 4), CONST 5))) => Bool true;
  (CONS (NIL, NIL)) => List [List []];
  (APPEND (NIL, CONS (TRUE, FALSE))) => raise UndefinedSemantics;
}